# Architecture

**Analysis Date:** 2026-01-21

## Pattern Overview

**Overall:** Modular DSL-based API client library with layered architecture for HTTP, WebSocket, and persistence operations.

**Key Characteristics:**
- **DSL-driven endpoint definitions** - `Hyperliquid.Api.Endpoint` macro reduces boilerplate for API request/response handling
- **Multi-context architecture** - Separates `:info`, `:exchange`, `:explorer`, and `:stats` API contexts
- **Storage abstraction** - Optional PostgreSQL and cache backends for persisting API responses
- **Registry-based endpoint discovery** - Central registry maps endpoint names to modules for dynamic invocation
- **Dual transport support** - HTTP for request-response, WebSocket for subscriptions

## Layers

**API Layer:**
- Purpose: High-level interfaces for interacting with Hyperliquid APIs
- Location: `lib/hyperliquid/api/`
- Contains: Endpoint modules using `Hyperliquid.Api.Endpoint` DSL, context-specific convenience functions
- Depends on: Transport layer, Ecto for validation, Registry for endpoint discovery
- Used by: External clients consuming the library

**Transport Layer:**
- Purpose: Low-level HTTP and WebSocket communication
- Location: `lib/hyperliquid/transport/`
- Contains: `Http` (HTTPoison-based requests with snake_case transformation), `WebSocket` (raw WS connections), `Rpc` (Ethereum JSON-RPC)
- Depends on: HTTPoison, Config for endpoint URLs
- Used by: API layer for actual network operations

**Storage Layer:**
- Purpose: Persistence of API responses to PostgreSQL and cache
- Location: `lib/hyperliquid/storage/`
- Contains: `Writer` GenServer for async/sync storage operations with batching
- Depends on: Ecto for database operations, Cachex for cache backend, Hyperliquid.Repo
- Used by: API endpoints with storage configuration enabled

**WebSocket Management:**
- Purpose: Subscription handling and connection pooling
- Location: `lib/hyperliquid/websocket/`
- Contains: `Manager` (subscription lifecycle), `Connection` (WS message handling), `Supervisor` (connection pooling)
- Depends on: WebSockets library, Transport layer
- Used by: API subscription endpoints

**Configuration & Infrastructure:**
- Purpose: Environment configuration, caching, RPC registry
- Location: `lib/hyperliquid/`
- Contains: `Config` (environment setup), `Cache` (Cachex-based caching), `Repo` (Ecto repository), `Application` (OTP supervision tree)
- Depends on: Application config, external libraries
- Used by: All layers

## Data Flow

**Standard API Request Flow (Info Endpoint):**

1. User calls `Hyperliquid.Api.Info.AllMids.request()` or `Hyperliquid.Api.command(:info, :all_mids)`
2. Endpoint module builds request payload via `build_request/N` (generated by DSL)
3. HTTP transport layer (`Hyperliquid.Transport.Http.info_request/2`) POSTs JSON to API
4. Response is received, automatically converted to snake_case by transport
5. Endpoint's `parse_response/1` validates response against Ecto schema
6. Parsed struct returned to user as `{:ok, result}`
7. If storage configured, `fetch/N` variant calls `Hyperliquid.Storage.Writer.store_async/2` to persist

**WebSocket Subscription Flow:**

1. User calls `Hyperliquid.WebSocket.Manager.subscribe(module, params)`
2. Manager generates subscription key (module + params hash)
3. Manager determines connection type (`:shared`, `:dedicated`, or `:user_grouped`)
4. If connection doesn't exist, DynamicSupervisor spawns new `Hyperliquid.WebSocket.Connection`
5. Connection establishes WebSocket, sends subscription message
6. Messages received on socket are routed to registered callback
7. Unsubscribe removes subscription entry, closes connection if no other subscribers

**Exchange Action Flow (Not Yet Migrated to DSL):**

1. User calls `Hyperliquid.Api.Exchange.Order.request(action_data)` (legacy pattern)
2. Request is built with user signature
3. HTTP transport POSTs to exchange endpoint
4. Response validated and returned

**State Management:**

- **Request state:** Stateless per-request, built fresh each call
- **Subscription state:** Managed in ETS table by WebSocket.Manager, persisted in GenServer state
- **Cache state:** Managed by Cachex (in-memory, TTL-based)
- **Database state:** Persisted via Ecto to PostgreSQL, written asynchronously by Storage.Writer
- **Connection state:** Managed by WebSocket.Connection GenServers, supervised by DynamicSupervisor

## Key Abstractions

**Endpoint:**
- Purpose: Reduces boilerplate for defining API endpoints with request building, validation, storage
- Examples: `lib/hyperliquid/api/info/all_mids.ex`, `lib/hyperliquid/api/info/l2_book.ex`
- Pattern: Uses Ecto schemas for response validation, DSL options for metadata

**Registry:**
- Purpose: Central discovery and routing for endpoint modules
- Examples: `lib/hyperliquid/api/registry.ex` maintains `@endpoints_by_context` map
- Pattern: Compile-time introspection of modules using `__endpoint_info__/0` function

**Transport Protocols:**
- Purpose: Abstract HTTP, WebSocket, and RPC communication details
- Examples: `Hyperliquid.Transport.Http`, `Hyperliquid.Transport.WebSocket`
- Pattern: Request/response handling with automatic camelCase to snake_case conversion

**Storage Backends:**
- Purpose: Pluggable persistence options (PostgreSQL, Cachex)
- Examples: Configured via `storage:` option in endpoint DSL
- Pattern: Async batched writes via GenServer, configurable via endpoint metadata

## Entry Points

**Application Entry:**
- Location: `lib/hyperliquid/application.ex`
- Triggers: OTP application startup
- Responsibilities: Supervises all child processes (PubSub, Cachex, RPC Registry, WebSocket Supervisor, optional Repo)

**Root API Module:**
- Location: `lib/hyperliquid/api.ex`
- Triggers: Direct user calls
- Responsibilities: Provides `command/3` and `command!/3` for dynamic endpoint invocation and Registry integration

**Direct Endpoint Call:**
- Location: `lib/hyperliquid/api/{info,explorer,stats}/*.ex`
- Triggers: User calls to specific endpoint modules
- Responsibilities: Execute request, parse response, optionally persist to storage

**Subscription Entry:**
- Location: `lib/hyperliquid/websocket/manager.ex`
- Triggers: User calls to `Manager.subscribe/2`
- Responsibilities: Manage subscription lifecycle, route messages to callbacks

## Error Handling

**Strategy:** Result tuples with error atoms or structs, bang (!) variants that raise Hyperliquid.Error

**Patterns:**

- **API Errors:** Returned as `{:error, reason}` from Transport.Http, propagated through endpoint layers
- **Validation Errors:** Ecto.Changeset errors formatted by endpoint modules, returned or raised
- **HTTP Errors:** Wrapped in `Hyperliquid.Error` struct with HTTP status and body
- **Schema Mismatch:** Response validation failure returns `{:error, changeset}`
- **Transport Failures:** Connection errors, timeouts returned as `{:error, {:http_error, details}}`

**Error Handling Examples:**
- `Hyperliquid.Api.command(:info, :all_mids)` → `{:error, :not_found}` if endpoint doesn't exist
- `AllMids.request()` → `{:error, changeset}` if response doesn't validate
- `AllMids.request!()` → raises `Hyperliquid.Error` on validation or HTTP failure

## Cross-Cutting Concerns

**Logging:** Uses standard Elixir Logger, called from Transport layer and Storage.Writer for error logging

**Validation:** Ecto.Changeset-based validation in each endpoint module's `changeset/2` function

**Authentication:** Signature generation in Exchange endpoints (legacy), optional user context in subscription params

**Telemetry:** DSL emits telemetry events via `:telemetry.execute/3`:
- `[:hyperliquid, :api, :request, :start]` - Request begins
- `[:hyperliquid, :api, :request, :stop]` - Request succeeds
- `[:hyperliquid, :api, :request, :exception]` - Request fails

**Rate Limiting:** Metadata tracked via `rate_limit_cost/0` in each endpoint, aggregated by Registry

**Caching:** Optional per-endpoint via `:cache` storage option, key interpolation with `{{field}}` patterns

---

*Architecture analysis: 2026-01-21*
